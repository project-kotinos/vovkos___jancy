.. include:: def.rst
.. index:: pair: class; io.Pcap
.. _doxid-type_io_pcap:

class io.Pcap
=============

.. toctree::
	:hidden:

	enum_io_Pcap_Defaults.rst

Overview
~~~~~~~~

This class provides high-level asynchronous interface for the Pcap
(Packet Capture) library. :ref:`More...<details-type_io_pcap>`


.. ref-code-block:: jancy
	:class: doxyrest-overview-code-block

	import "io_pcap.jncx"
	
	class Pcap
	{
		// enums
	
		enum :ref:`Defaults<doxid-type_io_pcap_defaults>`;

		// fields
	
		:ref:`size_t<doxid-typedef_size_t>` readonly :target:`m_snapshotSize<doxid-struct_member_io_pcap_m_snapshotsize>`;
		bool readonly :target:`m_isPromiscious<doxid-struct_member_io_pcap_m_ispromiscious>`;
		:ref:`uint_t<doxid-typedef_uint_t>` readonly :target:`m_readTimeout<doxid-struct_member_io_pcap_m_readtimeout>`;
		char const* readonly :ref:`m_filter<doxid-struct_member_io_pcap_m_filter>`;
		:ref:`uint_t<doxid-typedef_uint_t>` readonly :target:`m_unused<doxid-struct_member_io_pcap_m_unused>`;
		:ref:`io.PcapEvents<doxid-type_io_pcapevents>` readonly volatile :target:`m_activeEvents<doxid-struct_member_io_pcap_m_activeevents>`;
		:ref:`std.Error<doxid-type_std_error>` const* readonly volatile :target:`m_ioError<doxid-struct_member_io_pcap_m_ioerror>`;
		bool readonly :ref:`m_isOpen<doxid-struct_member_io_pcap_m_isopen>`;

		// properties
	
		:ref:`size_t<doxid-typedef_size_t>` autoget property :target:`m_readBufferSize<doxid-property_io_pcap_m_readbuffersize>`;

		// construction
	
		:target:`construct<doxid-function_io_pcap_construct>`();

		// methods
	
		bool errorcode :ref:`openDevice<doxid-function_io_pcap_opendevice>`(
			char const* deviceName,
			char const* filter,
			:ref:`uint_t<doxid-typedef_uint_t>` snapshotSize = Defaults . SnapshotSize,
			bool isPromiscious = Defaults . Promiscious,
			:ref:`uint_t<doxid-typedef_uint_t>` readTimeout = Defaults . ReadTimeout
			);
	
		bool errorcode :ref:`openFile<doxid-function_io_pcap_openfile>`(
			char const* fileName,
			char const* filter
			);
	
		void :ref:`close<doxid-function_io_pcap_close>`();
		bool errorcode :ref:`setFilter<doxid-function_io_pcap_setfilter>`(char const* filter);
	
		:ref:`size_t<doxid-typedef_size_t>` errorcode :ref:`read<doxid-function_io_pcap_read>`(
			void* p,
			:ref:`size_t<doxid-typedef_size_t>` size,
			:ref:`uint64_t<doxid-typedef_uint64_t>`* timestamp = null
			);
	
		:ref:`size_t<doxid-typedef_size_t>` errorcode :ref:`write<doxid-function_io_pcap_write>`(
			void const* p,
			:ref:`size_t<doxid-typedef_size_t>` size
			);
	
		long errorcode :target:`wait<doxid-function_io_pcap_wait>`(
			:ref:`io.PcapEvents<doxid-type_io_pcapevents>` eventMask,
			void function* handler (io.PcapEvents triggeredEvents)
			);
	
		bool errorcode :target:`cancelWait<doxid-function_io_pcap_cancelwait>`(long handle);
	
		:ref:`io.PcapEvents<doxid-type_io_pcapevents>` errorcode :target:`blockingWait<doxid-function_io_pcap_blockingwait>`(
			:ref:`io.PcapEvents<doxid-type_io_pcapevents>` eventMask,
			:ref:`uint_t<doxid-typedef_uint_t>` timeout
			);

		// aliases
	
		alias :ref:`dispose<doxid-alias_io_pcap_dispose>` = close;
	};
.. _details-type_io_pcap:

Detailed Documentation
~~~~~~~~~~~~~~~~~~~~~~

This class provides high-level asynchronous interface for the Pcap
(Packet Capture) library.

Pcap library(called WinPcap on Windows) is de-facto the standard tool for
capturing and injecting low-level network traffic.

A typical sequence of steps when working with ``io.Pcap`` looks something
like this:

* Open a live capture using ``openDevice`` or a capture file(\*.pcap) using
  ``openFile`` method;
* Assign IO event handler with ``wait`` method. You would probably also
  want to *schedule* your event handler to be run in particular
  environment(e.g., in a specific thread) and partially apply some
  syncrhonization ID to discard late events;
* When `io.PcapEvents.IncomingData` event is fired, read packet using
  ``read`` method;
* If you opened a live capture, you can also inject packets with ``write``
  method;
* Close Pcap object when no longer needed with ``close`` method.

Code sample:

.. ref-code-block::

	class MyDialog
	{
		// ...

		io.Pcap m_pcap;
		uint_t m_syncId;

		startCapture(
			char const* device,
			char const* filter = null
			);

		close();
		waitPcapEvents();

		onPcapEvent(
			uint_t syncId,
			`io.PcapEvents` triggeredEvents
			);
	}

	MyDialog.startCapture(
		char const* device,
		char const* filter = null
		)
	{
		bool result = try m_pcap.openDevice(device, filter);
		if (!result)
		{
			// handle the error...
		}

		waitPcapEvents();
	}

	MyDialog.close()
	{
		m_serial.close();
		m_syncId++; // events past this point will be discarded as 'late'
	}

	MyDialog.waitPcapEvent()
	{
		`io.PcapEvents` eventMask =
			`io.PcapEvents.IoError` |
			`io.PcapEvents.IncomingData`;

		m_serial.wait(eventMask, onPcapEvent ~(++m_syncId) @
			g_mainThreadScheduler);
	}

	MyDialog.onPcapEvent(
		uint_t syncId,
		`io.PcapEvents` triggeredEvents
		)
	{
		if (syncId != m_syncId) // late event
			return;

		if (triggeredEvents & `io.PcapEvents.IoError`)
		{
			char cont* errorString = m_pcap.m_ioError.m_description;
			// ...
		}

		if (triggeredEvents & `io.PcapEvents.IncomingData`)
		{
			char buffer[256];
			size_t size = m_pcap.read(buffer, sizeof(buffer));
			// ...
		}

		waitPcapEvents(); // restart wait
	}



.. rubric:: See also:

`io.PcapEvents`

Fields
------

.. index:: pair: variable; m_filter
.. _doxid-struct_member_io_pcap_m_filter:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	char const* readonly m_filter

Holds currently specified capture filter [#f4]_.

.. index:: pair: variable; m_isOpen
.. _doxid-struct_member_io_pcap_m_isopen:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	bool readonly m_isOpen

Holds the open status for the Pcap object, i.e. ``true`` if opened;
``false`` otherwise.

Methods
-------

.. index:: pair: function; openDevice
.. _doxid-function_io_pcap_opendevice:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	bool errorcode openDevice(
		char const* deviceName,
		char const* filter,
		:ref:`uint_t<doxid-typedef_uint_t>` snapshotSize = Defaults . SnapshotSize,
		bool isPromiscious = Defaults . Promiscious,
		:ref:`uint_t<doxid-typedef_uint_t>` readTimeout = Defaults . ReadTimeout
		)

Opens a network interface for Pcap capture.

The function accepts 3 arguments. The first one, ``deviceName``, is
used to specify the device to start capture on. To obtain a list of
available devices, use `io.createPcapDeviceDescList` function.

The second one, ``filter``, allows you to specify a capture filter
[#f4]_ which will be applied to incoming packets -- packets which do
not pass the filter, will never be signalled via
`io.PcapEvents.IncomingData` event and could not be read by ``read``
method.

The third and final parameter specifies whether to put interface in
promiscuous mode.

Returns ``true`` on success. If live capture on specified device could
not be opened, function sets the error reported by Pcap and returns
``false`` [#f1]_.

.. index:: pair: function; openFile
.. _doxid-function_io_pcap_openfile:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	bool errorcode openFile(
		char const* fileName,
		char const* filter
		)

Opens a previously captured \*.pcap file specified by ``fileName``
argument.

The second argument, ``filter``, has the same meaning as in
``openDevice`` method [#f4]_.

Returns ``true`` on success. If capture file could not be opened,
function sets the error reported by Pcap and returns ``false`` [#f1]_.

.. index:: pair: function; close
.. _doxid-function_io_pcap_close:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	void close()

Closes a previously opened live capture or a capture file, does nothing
if Pcap is not opened. This function always succeeds.

Sometimes it may be convenient to use *disposable* pattern to ensure
timely invokation of ``close`` [#f2]_.

.. index:: pair: function; setFilter
.. _doxid-function_io_pcap_setfilter:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	bool errorcode setFilter(char const* filter)

Allows you to change current capture filter without restarting the
capture.

Returns ``true`` on success. If capture filter could not be changed,
function sets the error reported by Pcap and returns ``false`` [#f1]_.

.. index:: pair: function; read
.. _doxid-function_io_pcap_read:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	:ref:`size_t<doxid-typedef_size_t>` errorcode read(
		void* p,
		:ref:`size_t<doxid-typedef_size_t>` size,
		:ref:`uint64_t<doxid-typedef_uint64_t>`* timestamp = null
		)

Reads the next packet into the buffer pointed to by ``p`` and ``size``
bytes long.

Returns the actual amount of bytes read or ``-1`` if error occurs.

If read operation is unsuccessful, function sets the error reported by
Pcap and returns ``-1`` [#f1]_.

Normally you would call this function from within your event handler for
``ReadyRead`` event. If this function is called when there are no
incoming pacets, it blocks until either a packet arrives, or Pcap is
closed.

.. index:: pair: function; write
.. _doxid-function_io_pcap_write:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	:ref:`size_t<doxid-typedef_size_t>` errorcode write(
		void const* p,
		:ref:`size_t<doxid-typedef_size_t>` size
		)

Attempts to inject ``size`` bytes from the buffer pointed to by ``p`` as
a packet on a currently opened device.

Returns the actual amount of bytes written on success. If write
operation is unsuccessful, function sets the error reported by Pcap and
returns ``-1`` [#f1]_.

Aliases
-------

.. index:: pair: alias; dispose
.. _doxid-alias_io_pcap_dispose:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	alias dispose = close

Effectively makes ``io.Pcap`` a *disposable* class [#f2]_.


---------------------

.. rubric:: Footnotes

.. [#f1]

	|footnote-errorcode|

.. [#f2]

	|footnote-disposable|

.. [#f3]

	|footnote-sync-id|

.. [#f4]

	For detailed description of the syntax used in Pcap capture filter
	expressions refer to: http://www.tcpdump.org/manpages/pcap-filter.7.html

