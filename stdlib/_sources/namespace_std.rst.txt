.. include:: def.rst
.. index:: pair: namespace; std
.. _doxid-namespace_std:

namespace std
=============

.. toctree::
	:hidden:

Overview
~~~~~~~~




.. ref-code-block:: jancy
	:class: doxyrest-overview-code-block

	
	namespace std {

	// typedefs

	typedef :ref:`size_t<doxid-typedef_size_t>` :target:`HashFunc<doxid-typedef_std_hashfunc>`(variant key);

	typedef bool :target:`IsEqualFunc<doxid-typedef_std_isequalfunc>`(
		variant key1,
		variant key2
		);

	typedef int :target:`CmpFunc<doxid-typedef_std_cmpfunc>`(
		variant key1,
		variant key2
		);

	// enums

	enum :ref:`BinTreeFindRelOp<doxid-type_std_bintreefindrelop>`;
	bitflag enum :ref:`GuidStringFlags<doxid-type_std_guidstringflags>`;

	// structs

	struct :ref:`Error<doxid-type_std_error>`;
	struct :ref:`Guid<doxid-type_std_guid>`;
	struct :ref:`ListEntry<doxid-type_std_listentry>`;
	struct :ref:`MapEntry<doxid-type_std_mapentry>`;

	// classes

	class :ref:`Array<doxid-type_std_array>`;
	class :ref:`Buffer<doxid-type_std_buffer>`;
	class :ref:`HashTable<doxid-type_std_hashtable>`;
	class :ref:`List<doxid-type_std_list>`;
	class :ref:`RbTree<doxid-type_std_rbtree>`;
	class :ref:`StringBuilder<doxid-type_std_stringbuilder>`;
	class :ref:`StringHashTable<doxid-type_std_stringhashtable>`;
	class :ref:`StringHashTableIgnoreCase<doxid-type_std_stringhashtableignorecase>`;

	// global variables

	static :ref:`std.Guid<doxid-type_std_guid>` :target:`g_errnoGuid<doxid-variable_std_g_errnoguid>` = { 0x25a6a7b5 , 0xf662 , 0x48ae , { 0xbc , 0xb6 , 0x9a , 0x5c , 0xb5 , 0xce , 0x5b , 0xb9 } };
	static :ref:`std.Guid<doxid-type_std_guid>` :target:`g_winErrorGuid<doxid-variable_std_g_winerrorguid>` = { 0x54e100e8 , 0x2137 , 0x40b8 , { 0xbc , 0xd8 , 0x00 , 0xac , 0x1d , 0x0b , 0xaa , 0x16 } };
	static :ref:`std.Guid<doxid-type_std_guid>` :target:`g_ntStatusGuid<doxid-variable_std_g_ntstatusguid>` = { 0x81443347 , 0x3bc9 , 0x4d5e , { 0x8b , 0x23 , 0x32 , 0xd7 , 0x80 , 0xed , 0xb5 , 0x2b } };

	// global functions

	:ref:`std.Error<doxid-type_std_error>` const* :ref:`getLastError<doxid-function_std_getlasterror>`();
	char const* :ref:`getLastErrorDescription<doxid-function_std_getlasterrordescription>`();
	void :ref:`setError<doxid-function_std_seterror>`(:ref:`std.Error<doxid-type_std_error>` const* error);
	void :ref:`setError<doxid-function_std_seterror_2>`(char const* string);
	void :ref:`setErrno<doxid-function_std_seterrno>`(int errno);

	char const* cdecl :ref:`format<doxid-function_std_format>`(
		char const* fmtSpecifier,
		...
		);

	void :ref:`resetDynamicLayout<doxid-function_std_resetdynamiclayout>`(void const* p);

	} // namespace std
.. _details-namespace_std:

Detailed Documentation
~~~~~~~~~~~~~~~~~~~~~~



Global Functions
----------------

.. index:: pair: function; setError
.. _doxid-function_std_seterror_2:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	void setError(char const* string)

Sets string error described by a null-terminated string pointed to by
``string`` as the last error of the current thread.

Calling `std.Error.m_description` on a string error will yield a
null-terminated string identical to ``string``.

.. index:: pair: function; resetDynamicLayout
.. _doxid-function_std_resetdynamiclayout:

.. ref-code-block:: jancy
	:class: doxyrest-title-code-block

	void resetDynamicLayout(void const* p)

Clears the cache of dynamically calculated offsets inside a
``dynamic struct``.

Jancy runtime optimizes access to dynamic structures by caching the
calucated offsets of dynamic fields. The cache is stored inside a buffer
itself(as part of jnc.Box, not as part of a dynamic pointer). Therefore,
it's necessary to drop this cache if you are about to re-use the same buffer
by re-writing it with another block of memory and analyzing it agani with
dynamic structures.

Note that dropping the cache is not required if you just want to analyze the
same buffer with other ``dynamic struct`` pointers -- the cache is smart
enough to distinguish between multiple dynamic structure types.

.. rubric:: Sample code:

.. ref-code-block::

	dynamic struct HeaderA
	{
		// ...
	};

	dynamic struct HeaderB
	{
		// ...
	};

	char buffer[1024];

	file.read(buffer, sizeof(buffer));

	HeaderA const* a = (HeaderA const*) buffer;

	// access the buffer via dynamic struct A...

	file.read(buffer, sizeof(buffer));

	// we need to drop the previous cache -- otherwise,
	// Jancy runtime will re-use pre-calculated offsets.
	// that, obviously, will yield wrong resultts (the data is different)

	std.resetDynamicLayout(buffer);

	HeaderA const* a = (HeaderA const*) buffer;

	// access the buffer via dynamic struct A...

	// no need to drop cache before accessing the same
	// buffer with a different dynamic struct pointer

	HeaderB const* b = (HeaderB const*) buffer;

