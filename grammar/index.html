

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Jancy Grammar Reference &mdash; Jancy Grammar Reference</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'./',
              VERSION:'2.0.0',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="#" class="icon icon-home"> Jancy Grammar Reference
          

          
          </a>

          
            
            
              <div class="version">
                2.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Jancy Grammar Reference</a><ul>
<li><a class="reference internal" href="#grammar-listing">Grammar Listing</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">Jancy Grammar Reference</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="#">Docs</a> &raquo;</li>
        
      <li>Jancy Grammar Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="jancy-grammar-reference">
<h1>Jancy Grammar Reference</h1>
<p>The present page provides the <strong>full Jancy grammar</strong> for reference purposes.</p>
<p>This listing is <strong>auto-generated</strong> from <code class="docutils literal notranslate"><span class="pre">.llk</span></code> files by <a class="reference external" href="http://github.com/vovkos/graco">Graco</a> parser generator, and is basically the <strong>very same</strong> grammar being used by the Jancy compiler. All the actions, rule attributes and rule arguments removed for readability.</p>
<p>Non-terminals are named using lower-case C-style naming convention (e.g. <code class="docutils literal notranslate"><span class="pre">global_declaration</span></code>); character terminals are denoted as C <code class="docutils literal notranslate"><span class="pre">char</span></code> literals (e.g. <code class="docutils literal notranslate"><span class="pre">';'</span></code>); non-char terminals have names starting with <code class="docutils literal notranslate"><span class="pre">TokenKind_</span></code> prefix (e.g. <code class="docutils literal notranslate"><span class="pre">TokenKind_Identifier</span></code>).</p>
<div class="section" id="grammar-listing">
<h2>Grammar Listing</h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lookahead = 2;

start
nullable
compilation_unit
	:	global_declaration*
	;

global_declaration
	:	common_declaration
	|	import_declaration
	|	namespace_declaration
	|	extension_declaration
	|	normal_item_declaration
	;

common_declaration
	:	using_declaration
	|	alignment_declaration
	|	named_type_specifier
	|	&#39;;&#39;
	;

using_declaration
	:	TokenKind_Using using_namespace_kind qualified_name_list &#39;;&#39;
	;

alignment_declaration
	:	TokenKind_Alignment &#39;=&#39;? alignment_value &#39;;&#39;
	|	TokenKind_Alignment &#39;(&#39; alignment_value &#39;)&#39;
	;

named_type_specifier
	:	enum_specifier
	|	struct_specifier
	|	union_specifier
	|	class_specifier
	|	library_specifier
	;

import_declaration
	:	TokenKind_Import TokenKind_Literal
	;

namespace_declaration
	:	TokenKind_Namespace qualified_name &#39;{&#39; global_declaration* &#39;}&#39;
	;

extension_declaration
	:	TokenKind_Extension TokenKind_Identifier &#39;:&#39; type_name &#39;{&#39; named_type_block_declaration* &#39;}&#39;
	;

start
normal_item_declaration
	:	item_declaration_w_specifier
	|	item_declaration_wo_specifier
	;

named_type_block_declaration
	:	common_declaration
	|	friend_declaration
	|	access_declaration
	|	normal_item_declaration
	|	setas_declaration
	;

friend_declaration
	:	TokenKind_Friend qualified_name_list &#39;;&#39;
	;

access_declaration
	:	access_specifier &#39;:&#39;
	;

setas_declaration
	:	TokenKind_SetAs &#39;=&#39;? setas_value &#39;;&#39;
	|	TokenKind_SetAs &#39;(&#39; setas_value &#39;)&#39;
	;

local_declaration
	:	common_declaration
	|	statement
	|	local_item_declaration
	|	catch_label
	|	finally_label
	|	nested_scope_label
	;

statement
	:	compound_stmt
	|	expression_stmt
	|	if_stmt
	|	switch_stmt
	|	reswitch_stmt
	|	while_stmt
	|	do_stmt
	|	for_stmt
	|	break_stmt
	|	continue_stmt
	|	return_stmt
	|	once_stmt
	|	try_stmt
	|	throw_stmt
	|	unsafe_stmt
	|	assert_stmt
	;

local_item_declaration
	:	item_declaration_w_specifier
	|	item_declaration_wo_specifier
	;

catch_label
	:	TokenKind_Catch &#39;:&#39;
	;

finally_label
	:	TokenKind_Finally &#39;:&#39;
	;

nested_scope_label
	:	TokenKind_NestedScope &#39;:&#39;
	;

qualified_name
	:	qualified_name_impl
	;

type_name
	:	type_name_impl
	;

using_namespace_kind
	:	TokenKind_Namespace
	|	TokenKind_Extension
	;

qualified_name_list
	:	qualified_name (&#39;,&#39; qualified_name)*
	;

access_specifier
	:	TokenKind_Public
	|	TokenKind_Protected
	;

alignment_value
	:	TokenKind_Integer
	|	TokenKind_Default
	;

setas_value
	:	type_name
	|	TokenKind_Default
	;

qualified_name_impl
	:	TokenKind_Identifier (&#39;.&#39; TokenKind_Identifier)*
	;

start
qualified_name_save_name
	:	qualified_name
	;

item_declaration_w_specifier
	:	declaration_specifier_list declarator_list
	;

item_declaration_wo_specifier_rslv
	:	declarator_qualifier (&#39;.&#39; declarator_qualifier)* &#39;(&#39;
	;

item_declaration_wo_specifier
	:	declarator_list
	;

declaration_specifier_list
	:	declaration_specifier+
	;

declarator_list
	:	declarator declarator_list_terminator
	;

declarator_qualifier
	:	TokenKind_Identifier
	|	TokenKind_Get
	|	TokenKind_Set
	|	TokenKind_PreConstruct
	|	TokenKind_Construct
	|	TokenKind_Destruct
	|	TokenKind_Static TokenKind_Construct
	|	TokenKind_Static TokenKind_Destruct
	|	TokenKind_Operator declarator_operator_qualifier
	;

declaration_body_pass1
	:	compound_stmt_pass1
	;

compound_stmt_pass1
	:	&#39;{&#39; statement_pass1* &#39;}&#39;
	;

statement_pass1
	:	compound_stmt_pass1
	|	TokenKind_Catch
	|	TokenKind_Finally
	|	TokenKind_NestedScope
	|	TokenKind_Case
	|	TokenKind_Default
	|	any
	;

type_name_impl
	:	type_specifier_modifier_list declarator_prefix* declarator_suffix*
	;

type_specifier_modifier_list
	:	type_specifier_modifier+
	;

declarator_prefix
	:	&#39;*&#39; type_modifier*
	;

declarator_suffix
	:	array_suffix
	|	function_suffix
	|	bitfield_suffix
	;

type_name_list
	:	type_name (&#39;,&#39; type_name)*
	;

attribute_block
	:	&#39;[&#39; attribute_declarator (&#39;,&#39; attribute_declarator)* &#39;]&#39;
	;

nullable
attribute_declarator
	:	TokenKind_Identifier (&#39;=&#39; expression_pass1)?
	|	epsilon
	;

expression_pass1
	:	expression_pass1_item+
	;

expression_pass1_item
	:	&#39;{&#39; expression_pass1_item* &#39;}&#39;
	|	&#39;[&#39; expression_pass1_item* &#39;]&#39;
	|	&#39;(&#39; expression_pass1_item* &#39;)&#39;
	|	any
	;

arg_list_pass1
	:	&#39;(&#39; arg_list_pass1_item* &#39;)&#39;
	;

arg_list_pass1_item
	:	&#39;(&#39; arg_list_pass1_item* &#39;)&#39;
	|	any
	;

curly_initializer_pass1
	:	curly_initializer_pass1_impl
	;

curly_initializer_pass1_impl
	:	&#39;{&#39; curly_initializer_pass1_item* &#39;}&#39;
	;

curly_initializer_pass1_item
	:	curly_initializer_pass1_impl
	|	any
	;

start
expression_save_value
	:	expression
	;

start
expression
	:	conditional_expr
	;

start
nullable
expression_or_empty_list_save_list
	:	expression_or_empty_list
	;

nullable
expression_or_empty_list
	:	expression (&#39;,&#39; expression_or_empty)*
	|	&#39;,&#39; expression_or_empty (&#39;,&#39; expression_or_empty)*
	|	epsilon
	;

conditional_expr
	:	logical_or_expr (&#39;?&#39; conditional_expr &#39;:&#39; conditional_expr)?
	;

nullable
expression_or_empty
	:	conditional_expr
	|	epsilon
	;

expression_list
	:	expression (&#39;,&#39; expression)*
	;

start
constant_expr
	:	conditional_expr
	;

start
constant_integer_expr
	:	expression
	;

logical_or_expr
	:	logical_and_expr (TokenKind_LogOr logical_and_expr)*
	;

logical_and_expr
	:	inclusive_or_expr (TokenKind_LogAnd inclusive_or_expr)*
	;

inclusive_or_expr
	:	exclusive_or_expr (&#39;|&#39; exclusive_or_expr)*
	;

exclusive_or_expr
	:	and_expr (&#39;^&#39; and_expr)*
	;

and_expr
	:	equality_expr (&#39;&amp;&#39; equality_expr)*
	;

equality_expr
	:	relational_expr (equality_operator relational_expr)*
	;

relational_expr
	:	shift_expr (relational_operator shift_expr)*
	;

equality_operator
	:	TokenKind_Eq
	|	TokenKind_Ne
	;

shift_expr
	:	additive_expr (shift_operator additive_expr)*
	;

relational_operator
	:	&#39;&lt;&#39;
	|	&#39;&gt;&#39;
	|	TokenKind_Le
	|	TokenKind_Ge
	;

additive_expr
	:	multiplicative_expr (additive_operator multiplicative_expr)*
	;

shift_operator
	:	TokenKind_Shl
	|	TokenKind_Shr
	;

multiplicative_expr
	:	at_expr (multiplicative_operator at_expr)*
	;

additive_operator
	:	&#39;+&#39;
	|	&#39;-&#39;
	;

at_expr
	:	assignment_expr (&#39;@&#39; assignment_expr)*
	;

multiplicative_operator
	:	&#39;*&#39;
	|	&#39;/&#39;
	|	&#39;%&#39;
	;

assignment_expr
	:	unary_expr assignment_operator_expr?
	;

unary_expr
	:	postfix_expr
	|	unary_operator_expr
	;

assignment_operator_expr
	:	assignment_operator conditional_expr
	|	&#39;=&#39; curly_initializer
	;

assignment_operator
	:	&#39;=&#39;
	|	TokenKind_RefAssign
	|	TokenKind_AddAssign
	|	TokenKind_SubAssign
	|	TokenKind_MulAssign
	|	TokenKind_DivAssign
	|	TokenKind_ModAssign
	|	TokenKind_ShlAssign
	|	TokenKind_ShrAssign
	|	TokenKind_AndAssign
	|	TokenKind_XorAssign
	|	TokenKind_OrAssign
	;

start
curly_initializer
	:	&#39;{&#39; curly_initializer_item (&#39;,&#39; curly_initializer_item)* &#39;}&#39;
	;

postfix_expr
	:	primary_expr postfix_operator*
	;

unary_operator_expr
	:	&#39;+&#39; unary_expr
	|	&#39;-&#39; unary_expr
	|	&#39;~&#39; unary_expr
	|	&#39;&amp;&#39; unary_expr
	|	&#39;*&#39; unary_expr
	|	&#39;!&#39; unary_expr
	|	TokenKind_Inc unary_expr
	|	TokenKind_Dec unary_expr
	|	try_operator_expr
	|	TokenKind_Dynamic? &#39;(&#39; type_name &#39;)&#39; unary_expr
	|	TokenKind_New new_operator_type new_operator_curly_initializer?
	;

try_operator_expr
	:	TokenKind_Try unary_expr
	;

cast_operator_rslv
	:	TokenKind_Dynamic? &#39;(&#39; type_specifier_modifier
	;

new_operator_type
	:	type_name_impl
	|	qualified_type_name TokenKind_Construct? &#39;(&#39; expression_or_empty_list &#39;)&#39;
	;

new_operator_curly_initializer
	:	curly_initializer
	;

type_name_w_constructor_rslv
	:	qualified_name TokenKind_Construct? &#39;(&#39;
	;

qualified_type_name
	:	basetype_qualified_name
	;

type_specifier_modifier
	:	type_specifier
	|	type_modifier
	;

primary_expr
	:	&#39;(&#39; conditional_expr &#39;)&#39;
	|	literal
	|	TokenKind_BaseType
	|	TokenKind_Identifier
	|	TokenKind_This
	|	TokenKind_Integer
	|	TokenKind_Fp
	|	TokenKind_True
	|	TokenKind_False
	|	TokenKind_Null
	|	TokenKind_Await expression
	|	TokenKind_SizeOf &#39;(&#39; type_name_or_expr &#39;)&#39;
	|	TokenKind_CountOf &#39;(&#39; type_name_or_expr &#39;)&#39;
	|	TokenKind_TypeOf &#39;(&#39; type_name_or_expr &#39;)&#39;
	|	TokenKind_Dynamic TokenKind_SizeOf &#39;(&#39; expression &#39;)&#39;
	|	TokenKind_Dynamic TokenKind_CountOf &#39;(&#39; expression &#39;)&#39;
	|	TokenKind_Dynamic TokenKind_TypeOf &#39;(&#39; expression &#39;)&#39;
	|	TokenKind_OffsetOf &#39;(&#39; expression_0 &#39;)&#39;
	|	TokenKind_BindingOf &#39;(&#39; conditional_expr &#39;)&#39;
	;

postfix_operator
	:	&#39;(&#39; expression_or_empty_list &#39;)&#39;
	|	&#39;~&#39; &#39;(&#39; expression_or_empty_list &#39;)&#39;
	|	&#39;[&#39; expression_or_empty &#39;]&#39;
	|	TokenKind_Inc
	|	TokenKind_Dec
	|	&#39;.&#39; member_operator
	|	TokenKind_Ptr member_operator
	;

member_operator
	:	TokenKind_Identifier
	|	TokenKind_Get
	|	TokenKind_Set
	;

literal
	:	literal_atom+
	;

type_name_or_expr
	:	type_name
	|	expression_0
	;

start
expression_0
	:	conditional_expr_0
	;

literal_atom
	:	TokenKind_Literal
	|	TokenKind_BinLiteral
	|	TokenKind_FmtLiteral expression TokenKind_FmtSpecifier?
	;

nullable
curly_initializer_item
	:	TokenKind_Identifier &#39;=&#39; (curly_initializer | expression)
	|	expression
	|	curly_initializer
	|	epsilon
	;

start
expression_save_value_0
	:	expression_0
	;

conditional_expr_0
	:	logical_or_expr_0 (&#39;?&#39; conditional_expr_0 &#39;:&#39; conditional_expr_0)?
	;

nullable
expression_or_empty_0
	:	conditional_expr_0
	|	epsilon
	;

expression_list_0
	:	expression_0 (&#39;,&#39; expression_0)*
	;

nullable
expression_or_empty_list_0
	:	expression_0 (&#39;,&#39; expression_or_empty_0)*
	|	&#39;,&#39; expression_or_empty_0 (&#39;,&#39; expression_or_empty_0)*
	|	epsilon
	;

logical_or_expr_0
	:	logical_and_expr_0 (TokenKind_LogOr logical_and_expr_0)*
	;

logical_and_expr_0
	:	inclusive_or_expr_0 (TokenKind_LogAnd inclusive_or_expr_0)*
	;

inclusive_or_expr_0
	:	exclusive_or_expr_0 (&#39;|&#39; exclusive_or_expr_0)*
	;

exclusive_or_expr_0
	:	and_expr_0 (&#39;^&#39; and_expr_0)*
	;

and_expr_0
	:	equality_expr_0 (&#39;&amp;&#39; equality_expr_0)*
	;

equality_expr_0
	:	relational_expr_0 (equality_operator relational_expr_0)*
	;

relational_expr_0
	:	shift_expr_0 (relational_operator shift_expr_0)*
	;

shift_expr_0
	:	additive_expr_0 (shift_operator additive_expr_0)*
	;

additive_expr_0
	:	multiplicative_expr_0 (additive_operator multiplicative_expr_0)*
	;

multiplicative_expr_0
	:	at_expr_0 (multiplicative_operator at_expr_0)*
	;

at_expr_0
	:	assignment_expr_0 (&#39;@&#39; assignment_expr_0)*
	;

assignment_expr_0
	:	unary_expr_0 (assignment_operator conditional_expr_0)?
	;

unary_expr_0
	:	postfix_expr_0
	|	unary_operator_expr_0
	;

postfix_expr_0
	:	primary_expr_0 postfix_operator_0*
	;

unary_operator_expr_0
	:	&#39;+&#39; unary_expr_0
	|	&#39;-&#39; unary_expr_0
	|	&#39;~&#39; unary_expr_0
	|	&#39;&amp;&#39; unary_expr_0
	|	&#39;*&#39; unary_expr_0
	|	&#39;!&#39; unary_expr_0
	|	TokenKind_Inc unary_expr_0
	|	TokenKind_Dec unary_expr_0
	|	TokenKind_Try unary_expr_0
	|	&#39;(&#39; type_name &#39;)&#39; unary_expr_0
	|	storage_specifier? TokenKind_New new_operator_sype_0
	;

storage_specifier
	:	TokenKind_Typedef
	|	TokenKind_Alias
	|	TokenKind_Static
	|	TokenKind_ThreadLocal
	|	TokenKind_Abstract
	|	TokenKind_Virtual
	|	TokenKind_Override
	|	TokenKind_Mutable
	|	TokenKind_Disposable
	;

new_operator_sype_0
	:	type_name
	|	qualified_type_name TokenKind_Construct? &#39;(&#39; expression_or_empty_list_0 &#39;)&#39;
	;

primary_expr_0
	:	&#39;(&#39; conditional_expr_0 &#39;)&#39;
	|	literal_0
	|	TokenKind_BaseType
	|	TokenKind_Identifier
	|	TokenKind_This
	|	TokenKind_Integer
	|	TokenKind_Fp
	|	TokenKind_True
	|	TokenKind_False
	|	TokenKind_Null
	|	TokenKind_Dynamic? TokenKind_SizeOf &#39;(&#39; type_name_or_expr_0 &#39;)&#39;
	|	TokenKind_Dynamic? TokenKind_CountOf &#39;(&#39; type_name_or_expr_0 &#39;)&#39;
	|	TokenKind_Dynamic? TokenKind_TypeOf &#39;(&#39; type_name_or_expr_0 &#39;)&#39;
	|	TokenKind_OffsetOf &#39;(&#39; expression_0 &#39;)&#39;
	|	TokenKind_BindingOf &#39;(&#39; conditional_expr_0 &#39;)&#39;
	;

postfix_operator_0
	:	&#39;(&#39; expression_or_empty_list_0 &#39;)&#39;
	|	&#39;~&#39; &#39;(&#39; expression_or_empty_list_0 &#39;)&#39;
	|	&#39;[&#39; expression_or_empty_0 &#39;]&#39;
	|	TokenKind_Inc
	|	TokenKind_Dec
	|	&#39;.&#39; member_operator_0
	|	TokenKind_Ptr member_operator_0
	;

member_operator_0
	:	TokenKind_Identifier
	|	TokenKind_Get
	|	TokenKind_Set
	;

literal_0
	:	literal_atom_0+
	;

type_name_or_expr_0
	:	type_name
	|	expression_0
	;

literal_atom_0
	:	TokenKind_Literal
	|	TokenKind_BinLiteral
	|	TokenKind_FmtLiteral expression_0 TokenKind_FmtSpecifier?
	;

start
compound_stmt
	:	&#39;{&#39; local_declaration* &#39;}&#39;
	;

start
constructor_compound_stmt
	:	&#39;{&#39; btm_construct_stmt* local_declaration* &#39;}&#39;
	;

btm_construct_stmt
	:	btm_construct_name &#39;(&#39; expression_or_empty_list &#39;)&#39;
	|	TokenKind_BaseType &#39;.&#39; TokenKind_Construct &#39;(&#39; expression_or_empty_list &#39;)&#39;
	|	&#39;;&#39;
	;

btm_construct_stmt_rslv
	:	TokenKind_Identifier &#39;.&#39; (TokenKind_Identifier &#39;.&#39;)* TokenKind_Construct
	;

btm_construct_name
	:	TokenKind_Identifier &#39;.&#39; (TokenKind_Identifier &#39;.&#39;)* TokenKind_Construct
	;

start
expression_stmt
	:	expression &#39;;&#39;
	;

if_stmt
	:	TokenKind_If &#39;(&#39; expression &#39;)&#39; statement (TokenKind_Else statement)?
	;

switch_stmt
	:	TokenKind_Switch &#39;(&#39; expression &#39;)&#39; &#39;{&#39; switch_block_stmt* &#39;}&#39;
	;

reswitch_stmt
	:	TokenKind_ReSwitch &#39;(&#39; expression &#39;,&#39; expression (&#39;,&#39; expression)? &#39;)&#39; &#39;{&#39; reswitch_block_stmt* &#39;}&#39;
	;

while_stmt
	:	TokenKind_While &#39;(&#39; expression &#39;)&#39; statement
	;

do_stmt
	:	TokenKind_Do statement TokenKind_While &#39;(&#39; expression &#39;)&#39;
	;

for_stmt
	:	TokenKind_For &#39;(&#39; (local_item_declaration | expression_or_empty_list &#39;;&#39;) for_stmt_condition &#39;;&#39; expression_list? &#39;)&#39; statement
	;

break_stmt
	:	TokenKind_Break &#39;;&#39;
	;

continue_stmt
	:	TokenKind_Continue &#39;;&#39;
	;

return_stmt
	:	TokenKind_Return expression? &#39;;&#39;
	;

once_stmt
	:	storage_specifier? TokenKind_Once statement
	;

try_stmt
	:	TokenKind_Try &#39;{&#39; local_declaration* &#39;}&#39;
	;

throw_stmt
	:	TokenKind_Throw &#39;;&#39;
	;

unsafe_stmt
	:	TokenKind_Unsafe &#39;{&#39; local_declaration* &#39;}&#39;
	;

assert_stmt
	:	TokenKind_Assert &#39;(&#39; expression_pass1 (&#39;,&#39; expression)? &#39;)&#39;
	;

switch_block_stmt
	:	TokenKind_Case constant_integer_expr &#39;:&#39;
	|	TokenKind_Default &#39;:&#39;
	|	local_declaration
	;

reswitch_block_stmt
	:	TokenKind_Case reswitch_case_literal &#39;:&#39;
	|	TokenKind_Default &#39;:&#39;
	|	local_declaration
	;

start
reswitch_case_literal
	:	literal
	;

nullable
for_stmt_condition
	:	expression
	|	epsilon
	;

start
reactor_body
	:	&#39;{&#39; (reactor_stmt | &#39;;&#39;)* &#39;}&#39;
	;

reactor_stmt
	:	local_item_declaration
	|	expression_stmt
	|	reactor_onevent_stmt
	;

reactor_onevent_stmt
	:	TokenKind_OnEvent reactor_event_name function_suffix declaration_body_pass1
	;

reactor_event_name
	:	&#39;(&#39; expression_list &#39;)&#39;
	|	TokenKind_BindingOf &#39;(&#39; expression &#39;)&#39;
	|	any+
	;

function_suffix
	:	&#39;(&#39; function_formal_argument_list? &#39;)&#39; function_modifier*
	;

start
reactor_body_0
	:	&#39;{&#39; (reactor_stmt_0 | &#39;;&#39;)* &#39;}&#39;
	;

reactor_stmt_0
	:	local_item_declaration
	|	expression_0 &#39;;&#39;
	|	reactor_onevent_stmt_0
	;

reactor_onevent_stmt_0
	:	TokenKind_OnEvent reactor_event_name_0 function_suffix reactor_compound_stmt_0
	;

reactor_event_name_0
	:	&#39;(&#39; expression_list_0 &#39;)&#39;
	|	TokenKind_BindingOf &#39;(&#39; expression_0 &#39;)&#39;
	|	any+
	;

reactor_compound_stmt_0
	:	&#39;{&#39; (reactor_compound_stmt_0 | any)* &#39;}&#39;
	;

declaration_specifier
	:	attribute_block
	|	storage_specifier
	|	access_specifier
	|	type_specifier
	|	type_modifier
	;

type_specifier
	:	TokenKind_Void
	|	TokenKind_Variant
	|	TokenKind_Class
	|	TokenKind_AnyData
	|	TokenKind_Bool
	|	TokenKind_Int
	|	TokenKind_IntPtr
	|	TokenKind_Char
	|	TokenKind_Short
	|	TokenKind_Long
	|	TokenKind_Float
	|	TokenKind_Double
	|	property_template_specifier
	|	qualified_type_name
	;

type_modifier
	:	TokenKind_Unsigned
	|	TokenKind_BigEndian
	|	TokenKind_Const
	|	TokenKind_ReadOnly
	|	TokenKind_CMut
	|	TokenKind_Volatile
	|	TokenKind_Weak
	|	TokenKind_Thin
	|	TokenKind_Safe
	|	TokenKind_Unsafe
	|	TokenKind_Cdecl
	|	TokenKind_Stdcall
	|	TokenKind_Thiscall
	|	TokenKind_Jnccall
	|	TokenKind_Array
	|	TokenKind_Function
	|	TokenKind_Property
	|	TokenKind_Bindable
	|	TokenKind_AutoGet
	|	TokenKind_Indexed
	|	TokenKind_Multicast
	|	TokenKind_Event
	|	TokenKind_Reactor
	|	TokenKind_ErrorCode
	|	TokenKind_Async
	;

property_template_specifier
	:	TokenKind_Property named_type_block_impl
	;

qualified_type_name_rslv
	:	basetype_qualified_name (&#39;(&#39; | &#39;[&#39; | &#39;=&#39;)?
	;

basetype_qualified_name
	:	TokenKind_BaseType
	|	TokenKind_BaseType &#39;.&#39; qualified_name_impl
	|	qualified_name_impl
	;

start
named_type_block_impl
	:	&#39;{&#39; named_type_block_declaration* &#39;}&#39;
	;

declarator
	:	declarator_prefix* declarator_name declarator_suffix* declarator_constructor?
	;

declarator_list_terminator
	:	declarator_w_curly_initializer
	|	declarator_wo_curly_initializer
	|	declaration_body_pass1
	;

declarator_name
	:	declarator_qualifier (&#39;.&#39; declarator_qualifier)*
	;

declarator_constructor
	:	TokenKind_Construct? arg_list_pass1
	;

declarator_w_curly_initializer
	:	&#39;=&#39; curly_initializer_pass1 (&#39;,&#39; declarator_list)?
	;

declarator_wo_curly_initializer
	:	(&#39;=&#39; expression_pass1)? (&#39;,&#39; declarator_list | &#39;;&#39;)
	;

declarator_operator_qualifier
	:	operator_name
	|	type_name
	|	&#39;(&#39; &#39;)&#39;
	|	TokenKind_Ellipsis
	|	TokenKind_Cdecl TokenKind_Ellipsis
	|	TokenKind_BindingOf
	;

operator_name
	:	&#39;~&#39;
	|	&#39;!&#39;
	|	TokenKind_Inc
	|	TokenKind_Dec
	|	TokenKind_Postfix TokenKind_Inc
	|	TokenKind_Postfix TokenKind_Dec
	|	TokenKind_Postfix? TokenKind_Ptr
	|	&#39;+&#39;
	|	&#39;-&#39;
	|	&#39;*&#39;
	|	&#39;/&#39;
	|	&#39;%&#39;
	|	TokenKind_Shl
	|	TokenKind_Shr
	|	&#39;&amp;&#39;
	|	&#39;^&#39;
	|	&#39;|&#39;
	|	TokenKind_Eq
	|	TokenKind_Ne
	|	&#39;&lt;&#39;
	|	TokenKind_Le
	|	&#39;&gt;&#39;
	|	TokenKind_Ge
	|	&#39;=&#39;
	|	TokenKind_RefAssign
	|	TokenKind_AddAssign
	|	TokenKind_SubAssign
	|	TokenKind_MulAssign
	|	TokenKind_DivAssign
	|	TokenKind_ModAssign
	|	TokenKind_ShlAssign
	|	TokenKind_ShrAssign
	|	TokenKind_AndAssign
	|	TokenKind_XorAssign
	|	TokenKind_OrAssign
	|	TokenKind_AtAssign
	|	TokenKind_LogAnd
	|	TokenKind_LogOr
	|	&#39;[&#39; &#39;]&#39;
	|	&#39;@&#39;
	;

array_suffix
	:	&#39;[&#39; &#39;]&#39;
	|	&#39;[&#39; expression_pass1 &#39;]&#39;
	;

function_suffix_rslv
	:	&#39;(&#39; &#39;)&#39;
	|	&#39;(&#39; TokenKind_Ellipsis &#39;)&#39;
	|	&#39;(&#39; (type_specifier | type_modifier)
	;

bitfield_suffix
	:	&#39;:&#39; TokenKind_Integer
	;

function_formal_argument_list
	:	function_formal_argument (&#39;,&#39; function_formal_argument)*
	;

function_modifier
	:	TokenKind_Const
	;

function_formal_argument
	:	declaration_specifier_list declarator_prefix* declarator_name? declarator_suffix* (&#39;=&#39; expression_pass1)?
	|	TokenKind_Ellipsis
	;

enum_specifier
	:	enum_modifier* TokenKind_Enum TokenKind_Identifier? (&#39;:&#39; type_name)? enum_block
	;

struct_specifier
	:	TokenKind_Dynamic? TokenKind_Struct TokenKind_Identifier? (&#39;:&#39; type_name_list)? named_type_block
	;

union_specifier
	:	TokenKind_Dynamic? TokenKind_Union TokenKind_Identifier? named_type_block
	;

class_specifier
	:	TokenKind_Opaque? TokenKind_Class TokenKind_Identifier (&#39;:&#39; type_name_list)? named_type_block
	;

library_specifier
	:	TokenKind_DynamicLib TokenKind_Identifier &#39;{&#39; named_type_block_declaration* &#39;}&#39;
	;

start
named_type_specifier_save_type
	:	named_type_specifier
	;

enum_modifier
	:	TokenKind_Exposed
	|	TokenKind_BitFlag
	;

enum_block
	:	&#39;{&#39; enum_member (&#39;,&#39; enum_member)* &#39;}&#39;
	;

nullable
enum_member
	:	TokenKind_Identifier (&#39;=&#39; expression_pass1)?
	|	epsilon
	;

named_type_block
	:	named_type_block_impl
	;

</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-2019, Tibbo Technology Inc

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>